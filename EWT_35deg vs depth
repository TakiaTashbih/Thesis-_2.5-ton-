# -*- coding: utf-8 -*-
"""
EWT vs Depth (10th-year, Mar–Oct season) — SERIES vs PARALLEL, MIFT
- Four cases: (Series/Parallel) × (Equal branch flow / Equal total flow)
- Simulates full 10-year history (2025..2034), then extracts 2034 season peaks
- Prints minimum depth at 35 °C cap (interpolated and grid)
- Clean plots in Times New Roman

Requires: pygfunction >= 2.3.x
"""

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import calendar, datetime as dt
import pygfunction as gt

# ---------------- Figure style ----------------
mpl.rcParams['font.family'] = 'Times New Roman'
mpl.rcParams['font.size'] = 12

# ============================ User choices ============================
TON          = 2.5                   # cooling tonnage
EWT_CAP_C    = 35.0                  # EWT design cap for sizing
START_HOUR   = 10                    # ON start (10:00)
HOURS_ON     = 8                     # ON duration per day
MONTHS_ON    = range(3, 11)          # Mar..Oct inclusive
YEARS        = 10                    # 2025..2034
YEAR0        = 2025
H_GRID       = np.arange(30.0, 150.0 + 1e-9, 5.0)  # sweep grid [m]

# Borefield layout
N1, N2 = 4, 1                        # 4 bores in a row
B      = 7.5                         # spacing [m]
D      = 4.0                         # burial depth [m]
r_b    = 0.1532/2                    # bore radius [m]

# Ground / materials
T_g, k_s, alpha = 25.0, 2.45, 1.0e-6
k_g, k_p = 2.98, 0.70

# Pipe / fluid
r_out, r_in = 33.6e-3/2, 27.4e-3/2
D_s = 0.11/2
epsilon = 1e-6
pos = [(-D_s, 0.0), (D_s, 0.0)]
m_flow_bore_base = 0.30              # branch mass flow per bore [kg/s]
fluid = gt.media.Fluid('Water', 30.0)
cp_f, rho_f, mu_f, k_f = fluid.cp, fluid.rho, fluid.mu, fluid.k

# Time grid (hourly)
dt_sec = 3600.0

# g-function options
OPTS_SERIES   = {'nSegments': 8, 'disp': False}
OPTS_PARALLEL = {'nSegments': 8, 'disp': False}

# ============================== Helpers ===============================
def build_year_schedule(year, months_on, start_hour, on_hours, Q_on):
    hours = (366 if calendar.isleap(year) else 365) * 24
    Q = np.zeros(hours)
    t0 = dt.datetime(year, 1, 1)
    for m in months_on:
        days = calendar.monthrange(year, m)[1]
        for d in range(1, days + 1):
            for h in range(start_hour, start_hour + on_hours):
                hh = h % 24
                idx = int((dt.datetime(year, m, d, hh) - t0).total_seconds() // 3600)
                if 0 <= idx < hours:
                    Q[idx] = Q_on
    return Q

def build_multi_year_schedule(year0, years, months_on, start_hour, on_hours, Q_on):
    Q_years = []; year_offsets = [0]
    for i in range(years):
        y = year0 + i
        Qy = build_year_schedule(y, months_on, start_hour, on_hours, Q_on)
        Q_years.append(Qy)
        year_offsets.append(year_offsets[-1] + Qy.size)
    Q_series = np.concatenate(Q_years)
    return Q_series, np.array(year_offsets[:-1])  # starts of years 0..years-1

def season_slice_for_year(index_in_0_to_years_minus_1, Q_series, year_offsets):
    y0 = year_offsets[index_in_0_to_years_minus_1]
    y1 = year_offsets[index_in_0_to_years_minus_1 + 1] if index_in_0_to_years_minus_1 + 1 < len(year_offsets) \
         else Q_series.size
    Qy = Q_series[y0:y1]
    if not np.any(Qy):
        return slice(y0, y0)
    start = y0 + np.argmax(Qy != 0)
    stop  = y1 - np.argmax(Qy[::-1] != 0)
    return slice(start, stop)

def pipe_resistance(m_flow_branch):
    R_p = gt.pipes.conduction_thermal_resistance_circular_pipe(r_in, r_out, k_p)
    h_f = gt.pipes.convective_heat_transfer_coefficient_circular_pipe(
        m_flow_branch, r_in, mu_f, rho_f, k_f, cp_f, epsilon
    )
    R_f = 1.0 / (h_f * 2 * np.pi * r_in)
    return R_p + R_f

def make_network(H, topology, m_flow_branch):
    borefield = gt.boreholes.rectangle_field(N1, N2, B, B, H, D, r_b)
    nB = len(borefield)
    Rtube = pipe_resistance(m_flow_branch)
    UTubes = [gt.pipes.SingleUTube(pos, r_in, r_out, bh, k_s, k_g, Rtube) for bh in borefield]
    if topology == 'series':
        conn = [i - 1 for i in range(nB)]   # chain
        m_flow_network = m_flow_branch
    elif topology == 'parallel':
        conn = [-1] * nB                     # common headers
        m_flow_network = m_flow_branch * nB
    else:
        raise ValueError("topology must be 'series' or 'parallel'")
    net = gt.networks.Network(borefield, UTubes, bore_connectivity=conn)
    H_tot = sum(b.H for b in borefield)
    return net, m_flow_network, H_tot

def simulate(topology, H, Q_series, m_flow_branch):
    """Simulate the full horizon Q_series; return temps over the whole range."""
    net, m_flow_net, H_tot = make_network(H, topology, m_flow_branch)
    Nt = len(Q_series)
    time = dt_sec * (np.arange(Nt) + 1)
    LoadAgg = gt.load_aggregation.ClaessonJaved(dt_sec, time[-1])
    gFunc = gt.gfunction.gFunction(
        net, alpha,
        time=LoadAgg.get_times_for_simulation(),
        m_flow_network=m_flow_net, cp_f=cp_f,
        boundary_condition='MIFT',
        options=(OPTS_SERIES if topology == 'series' else OPTS_PARALLEL),
        method='equivalent'  # robust
    )
    LoadAgg.initialize(gFunc.gFunc / (2 * np.pi * k_s))

    T_b  = np.zeros(Nt)
    T_in = np.zeros(Nt)
    T_out = np.zeros(Nt)

    for i, (t, Q) in enumerate(zip(time, Q_series)):
        LoadAgg.next_time_step(t)
        LoadAgg.set_current_load(Q / H_tot)   # W/m
        dT = LoadAgg.temporal_superposition()
        Tb = T_g - dT
        T_b[i] = Tb
        Tin  = net.get_network_inlet_temperature(Q, Tb, m_flow_net, cp_f, nSegments=3)
        T_in[i] = Tin
        T_out[i] = net.get_network_outlet_temperature(Tin, Tb, m_flow_net, cp_f, nSegments=3)
    return T_out, T_in, T_b

def sweep_peak_ewt(topology, H_grid, Q_full, m_flow_branch, sl_season):
    """For each H: simulate full history, then return peak EWT within sl_season."""
    peaks = np.empty_like(H_grid, dtype=float)
    for i, H in enumerate(H_grid):
        print(f"[{topology}] H = {H:.1f} m ({i+1}/{len(H_grid)})")
        Tout, _, _ = simulate(topology, H, Q_full, m_flow_branch)
        peaks[i] = np.nanmax(Tout[sl_season])
    return peaks

def min_depth_at_cap(H, P, cap):
    """Linear interpolation for smallest depth H* where P(H)<=cap. Returns (H*, H_grid, ok)."""
    mask = np.isfinite(P)
    Hf, Pf = H[mask], P[mask]
    if Hf.size == 0 or not np.any(Pf <= cap):
        return None, None, False
    i = np.argmax(Pf <= cap)       # first at/below cap
    H_disc = float(Hf[i])
    if i == 0:
        return H_disc, H_disc, True
    H1, H2 = Hf[i-1], Hf[i]; P1, P2 = Pf[i-1], Pf[i]
    H_star = H1 + (cap - P1) * (H2 - H1) / (P2 - P1) if not np.isclose(P2, P1) else H2
    return float(H_star), H_disc, True

# ========================== Seasonal schedule =========================
Q_on = -1000.0 * 3.517 * TON  # W, cooling → inject (negative)
Q_series, year_offsets = build_multi_year_schedule(
    YEAR0, YEARS, MONTHS_ON, START_HOUR, HOURS_ON, Q_on
)

# Slice for the 10th year's Mar–Oct season (index 9 => 2034)
sl_2034 = season_slice_for_year(9, Q_series, year_offsets)

print(f"[Schedule] Using 10th-year (2034) season for peaks; months: Mar–Oct; hours/day: {HOURS_ON}")

# ============================ Run depth sweeps =========================
N_BORES = N1 * N2

# Equal BRANCH flow: same branch kg/s in both topologies
pe_series_eqBranch   = sweep_peak_ewt('series',   H_GRID, Q_series, m_flow_bore_base, sl_2034)
pe_parallel_eqBranch = sweep_peak_ewt('parallel', H_GRID, Q_series, m_flow_bore_base, sl_2034)

# Equal TOTAL flow: same total kg/s; series branch = total; parallel branch = total/N
m_total_eq = N_BORES * m_flow_bore_base
pe_series_eqTotal   = sweep_peak_ewt('series',   H_GRID, Q_series, m_total_eq,              sl_2034)
pe_parallel_eqTotal = sweep_peak_ewt('parallel', H_GRID, Q_series, m_total_eq / N_BORES,    sl_2034)

# ============================== Plots =================================
def plot_sweep(H, y1, y2, title):
    fig, ax = plt.subplots(figsize=(7.5,4.8))
    ax.plot(H, y1, marker='o', ms=4, lw=1.3, label="Series")
    ax.plot(H, y2, marker='s', ms=4, lw=1.3, label="Parallel")
    ax.axhline(EWT_CAP_C, ls='--', lw=1.0, color='k', label=f"EWT cap {EWT_CAP_C:.0f} °C")
    # Interpolated min depths
    for label, y in [("Series", y1), ("Parallel", y2)]:
        H_star, H_disc, ok = min_depth_at_cap(H, y, EWT_CAP_C)
        if ok:
            ax.axvline(H_star, ls=':', lw=1.0, color='gray')
    ax.set_xlabel("Borehole depth per bore [m]")
    ax.set_ylabel("2034 seasonal peak EWT [°C]")
    ax.set_title(title)
    ax.grid(True, alpha=0.25)
    ax.legend(frameon=False, loc="best")
    plt.tight_layout(); plt.show()

plot_sweep(H_GRID, pe_series_eqBranch,   pe_parallel_eqBranch,
           "EWT vs Depth — Equal branch flow (2034 season)")
plot_sweep(H_GRID, pe_series_eqTotal,    pe_parallel_eqTotal,
           "EWT vs Depth — Equal total flow (2034 season)")

# ============================ Printed summary ==========================
def print_line(name, m_branch, m_total, peaks):
    H_star, H_disc, ok = min_depth_at_cap(H_GRID, peaks, EWT_CAP_C)
    if ok:
        print(f"{name:34s}  branch ṁ={m_branch:5.2f} kg/s  total ṁ={m_total:5.2f} kg/s  "
              f"H*={H_star:6.1f} m  (grid {H_disc:5.1f} m)")
    else:
        print(f"{name:34s}  branch ṁ={m_branch:5.2f} kg/s  total ṁ={m_total:5.2f} kg/s  "
              f"H*>max({H_GRID[-1]:.0f} m)")

print("\nDesign depth at EWT cap = 35.0 °C (10th-year season, Mar–Oct):")
print_line("Series — equal branch",   m_flow_bore_base,      N_BORES*m_flow_bore_base, pe_series_eqBranch)
print_line("Parallel — equal branch", m_flow_bore_base,      N_BORES*m_flow_bore_base, pe_parallel_eqBranch)
print_line("Series — equal total",    m_total_eq,            m_total_eq,               pe_series_eqTotal)
print_line("Parallel — equal total",  m_total_eq/N_BORES,    m_total_eq,               pe_parallel_eqTotal)
